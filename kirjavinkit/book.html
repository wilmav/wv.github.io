<!DOCTYPE html>
<html lang="fi">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kirjan tiedot | Kirjavinkit</title>
    <link rel="stylesheet" href="../tyyli.css">
    <link rel="stylesheet" href="style.css">
    <link rel="icon" type="image/svg+xml" href="../favicon.svg">
    <script src="../dates_data.js"></script>
</head>

<body>
    <header>
        <a href="../index.html" class="app-logo-link" style="text-decoration:none;">
            <div class="app-title">Sovellukset<span class="app-title-com">.com</span></div>
        </a>
        <nav>
            <ul>
                <li><a href="../index.html">Etusivu</a></li>
                <li><a href="index.html"><strong>Kirjavinkit</strong></a></li>
                <li><a href="../kuitulaskuri.html">Kuitulaskuri</a></li>
                <li><a href="../SpotVaiFix.html">SpotVaiFix</a></li>
                <li><a href="../yhteystiedot.html">Ota yhteyttä / Contact</a></li>
            </ul>
        </nav>
    </header>

    <div class="content-wrapper">
        <main>
            <!-- Info Icon (Added per user request) -->
            <div class="info-icon-container" tabindex="0">
                <div class="info-icon">i</div>
                <div class="info-tooltip">
                    <p><strong>Lähteet:</strong></p>
                    <ul style="margin: 4px 0 8px 1.2rem; padding:0; list-style-type: disc;">
                        <li><a href="https://www.finna.fi" target="_blank" rel="noopener">Finna.fi</a> (Perustiedot)
                        </li>
                        <li><a href="https://books.google.com" target="_blank" rel="noopener">Google Books</a>
                            (Kuvaukset ja kannet)</li>
                        <li><a href="https://openlibrary.org" target="_blank" rel="noopener">Open Library</a>
                            (Arvostelut ja kannet)</li>
                    </ul>
                    <p>Palvelu on kokeiluasteella. Tiedot tarjotaan sitoumuksetta, eikä niiden oikeellisuudesta
                        voida taata kaikissa tilanteissa.</p>
                </div>
            </div>

            <section class="book-detail">
                <div id="detail-container"
                    style="background: white; padding: 2rem; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); margin-top: 2rem;">

                    <!-- Header with Title & Back Link -->
                    <div
                        style="display:flex; justify-content:space-between; align-items:flex-start; margin-bottom:1rem; flex-wrap:wrap; gap:1rem; width:100%;">
                        <h2 id="book-title" style="margin:0; flex:1;">Ladataan...</h2>
                        <a href="index.html"
                            style="margin-left:auto; color:#57606a; text-decoration:none; font-weight:500; font-size:1rem; display:flex; align-items:center;">
                            ← Takaisin listaukseen
                        </a>
                    </div>

                    <div style="display:flex; gap: 2rem; flex-wrap: wrap; align-items: start;">
                        <div style="flex-shrink:0; width:160px; display:flex; flex-direction:column; gap:12px;">
                            <div id="book-cover"
                                style="width: 100%; aspect-ratio: 2/3; background: #f6f8fa; border-radius: 4px; overflow:hidden; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                            </div>

                        </div>
                        <div class="info" style="flex:1; min-width: 250px;">
                            <!-- Author prominent -->
                            <h3 id="book-author"
                                style="color: #1f2328; margin-top:0; font-size: 1.1rem; font-weight: 600; margin-bottom: 0.25rem;">
                            </h3>

                            <!-- Original Title -->
                            <div id="book-original-title"
                                style="font-size: 0.9rem; color: #57606a; font-style: italic; margin-bottom: 0.5rem; display:none;">
                            </div>

                            <!-- Meta Tags Row (Year, Format, ISBN) -->
                            <div id="book-meta-tags"
                                style="display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin-bottom: 1.5rem;">
                                <!-- Year will be injected here -->
                                <span id="book-year"></span>
                                <!-- Format tags injected here via JS -->
                                <span id="book-formats"></span>
                                <!-- ISBN injected here -->
                                <div id="book-isbn-container" style="display:none;"></div>
                            </div>

                            <!-- Reviews Section (Hidden until valid) -->
                            <div id="reviews-container" style="margin-bottom: 1.5rem; display:none;">
                                <h4 style="margin:0 0 8px 0; font-size:1rem;">Arvostelut</h4>
                                <div id="review-content"></div>
                            </div>

                            <!-- Scrollable Description -->
                            <div class="scrollable-content">
                                <p id="book-desc"
                                    style="line-height: 1.6; color: #24292f; white-space: pre-wrap; margin:0; font-size: 1rem;">
                                </p>
                            </div>

                            <!-- Similar Books -->
                            <div id="similar-container" style="margin-top: 2rem; display:none;">
                                <h4 style="margin-bottom:1rem;">Samankaltaisia kirjoja</h4>
                                <div id="similar-list"
                                    style="display:flex; gap:16px; overflow-x:auto; padding-bottom:8px;"></div>
                            </div>


                        </div>
                    </div>
                </div>
            </section>
        </main>
    </div>

    <script>
        // Placeholder simple script for interaction
        // Theme Logic
        const savedTheme = localStorage.getItem('theme');
        if (savedTheme === 'dark') {
            document.body.classList.add('dark-mode');
        }

        // Add Toggle
        const toggleBtn = document.createElement('button');
        toggleBtn.className = 'theme-toggle';
        toggleBtn.title = "Vaihda teemaa";
        // Default icon based on current state
        if (savedTheme === 'dark') {
            toggleBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>`;
        } else {
            toggleBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>`;
        }

        toggleBtn.addEventListener('click', () => {
            document.body.classList.toggle('dark-mode');
            const isDark = document.body.classList.contains('dark-mode');
            localStorage.setItem('theme', isDark ? 'dark' : 'light');
            // Update Icon
            if (isDark) {
                toggleBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>`;
            } else {
                toggleBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>`;
            }
        });
        document.body.appendChild(toggleBtn);

        // --- Aggressive Cache Cleanup ---
        Object.keys(localStorage).forEach(key => {
            if (key.startsWith('isbn_') || key.startsWith('cover_')) {
                const val = localStorage.getItem(key);
                if (val === '9789523765061') localStorage.removeItem(key);
                if (key.includes('undefined') || val === 'undefined') localStorage.removeItem(key);
                if (key.toLowerCase().includes('sokeiden')) localStorage.removeItem(key);
            }
        });


        const params = new URLSearchParams(window.location.search);
        const bookId = params.get('id');

        let globalDates = {}; // Store dates globally

        // Load from global if available (CORS fix)
        if (typeof window.MANUAL_DATES !== 'undefined') {
            globalDates = window.MANUAL_DATES;
        } else {
            // Fallback to fetch
            fetch('../dates.json').then(r => r.json()).then(d => { globalDates = d; }).catch(e => console.warn("Dates fetch fail", e));
        }

        if (bookId) {
            fetchBookDetails(bookId);
        } else {
            document.getElementById('book-title').textContent = "Virhe: Kirjan tunnistetta ei annettu.";
        }

        async function fetchBookDetails(id) {
            // (Removed redundant fetch call here since it's handled above)

            const apiParams = new URLSearchParams();
            apiParams.append('lookfor', id);
            apiParams.append('type', 'id');
            apiParams.append('field[]', 'title');
            apiParams.append('field[]', 'authors');
            apiParams.append('field[]', 'year');
            apiParams.append('field[]', 'summary');
            apiParams.append('field[]', 'images');
            apiParams.append('field[]', 'subjects');
            apiParams.append('field[]', 'genres');        // For minimal filter
            apiParams.append('field[]', 'targetAudience');// For minimal filter
            apiParams.append('field[]', 'isbn');
            apiParams.append('field[]', 'notes');
            apiParams.append('field[]', 'publicationDates'); // Request detailed dates
            apiParams.append('field[]', 'formats'); // Need formats for date matching

            const url = `https://api.finna.fi/v1/search?${apiParams.toString()}`;

            try {
                const res = await fetch(url);
                const data = await res.json();

                if (data.records && data.records.length > 0) {
                    let book = data.records[0];

                    // Extract Original Title early
                    let originalTitle = "";
                    if (book.notes) {
                        const otNote = book.notes.find(n => n.includes("Alkuteos:") || n.includes("Alkuperäisteos:"));
                        if (otNote) {
                            originalTitle = otNote.replace("Alkuteos:", "").replace("Alkuperäisteos:", "").trim();
                        }
                    }
                    book.parsedOriginalTitle = originalTitle; // Store for usage

                    // Wait a tiny bit for dates if they are racing, or just re-render when dates arrive?
                    // We'll just render with what we have, then re-render if needed? 
                    // Simpler: Just render. The date fetch is fast local file.
                    // Let's await it to be sure for this view.
                    if (Object.keys(globalDates).length === 0) {
                        try {
                            const dateRes = await fetch('../dates.json');
                            if (dateRes.ok) globalDates = await dateRes.json();
                        } catch (e) { }
                    }

                    // --- FIX: Inject Manual ISBN immediately ---
                    if (globalDates && book.title) {
                        const key = book.title.toLowerCase()
                            .split(':')[0]
                            .split('/')[0]
                            .replace(/[.,]/g, '')
                            .trim();
                        const entry = globalDates[key];
                        if (entry && entry.isbn) {
                            // Force manual ISBN as the primary one
                            book.isbn = [entry.isbn];
                            console.log(`[Fix] Injected manual ISBN for ${book.title}: ${entry.isbn}`);
                        }
                    }
                    // -------------------------------------------

                    renderBook(book); // Render initial state

                    // PARALLEL ENRICHMENT PIPELINE (Optimized)
                    const enrichmentTasks = [];

                    // 1. Siblings Enrichment (Summary & Cover from other formats)
                    if ((!book.summary || book.summary.length === 0) || (!book.images || book.images.length === 0)) {
                        enrichmentTasks.push(enrichFromSiblings(book));
                    }

                    // 2. Google Books Enrichment (Covers & Summaries)
                    // Always try Google if image is missing, even if Finna has Summary
                    if ((!book.images || book.images.length === 0) || (!book.summary)) {
                        enrichmentTasks.push(enrichWithGoogleBooks(book, originalTitle));
                    }

                    // 3. Reviews (OpenLibrary)
                    if (book.isbn) enrichmentTasks.push(fetchReviews(book.isbn));
                    else enrichmentTasks.push(fetchReviewsByTitle(book.title, extractAuthor(book)));

                    // 4. Similar Books (Independent)
                    findSimilarBooks(book);

                    // Execute all independent fetch tasks
                    await Promise.allSettled(enrichmentTasks);

                } else {
                    document.getElementById('book-title').textContent = "Kirjaa ei löytynyt.";
                }
            } catch (e) {
                console.error(e);
                document.getElementById('book-title').textContent = "Virhe ladattaessa tietoja.";
            }
        }

        // Use Google Books API to enrich data (description, cover, etc.)
        async function enrichWithGoogleBooks(book, originalTitle) {
            const cacheKey = `cover_fix_${book.id}`;
            const cachedUrl = localStorage.getItem(cacheKey);

            const updateImages = (url) => {
                // 1. Update Main Cover if it matches
                const detailCover = document.getElementById('book-cover');
                const urlParams = new URLSearchParams(window.location.search);
                if (urlParams.get('id') === book.id || detailCover.dataset.id === book.id) {
                    detailCover.innerHTML = `<img src="${url}" alt="${book.title}" style="width:100%; height:100%; object-fit:cover;" onerror="handleDetailCoverError(this, '${book.id}')">`;
                }

                // 2. Update Similar Books
                const similarImgs = document.querySelectorAll(`.similar-book-img[data-id="${book.id}"]`);
                similarImgs.forEach(img => {
                    img.src = url;
                    img.style.display = 'block';
                    if (img.parentElement.querySelector('div')) {
                        img.parentElement.querySelector('div').style.display = 'none';
                    }
                });
            };

            if (cachedUrl) {
                updateImages(cachedUrl);
            }

            const applyData = (items) => {
                if (items && items.length > 0) {
                    const info = items[0].volumeInfo;

                    // 1. Description (if missing and is main book)
                    const urlParams = new URLSearchParams(window.location.search);
                    if (urlParams.get('id') === book.id) {
                        const descEl = document.getElementById('book-desc');
                        if ((!descEl.innerText || descEl.innerText.length < 10) && info.description) {
                            descEl.innerText = info.description;
                            descEl.parentElement.style.display = 'block';
                            descEl.parentElement.insertAdjacentHTML('beforeend', '<div style="font-size:0.8rem; color:#888; margin-top:8px;">Kuvaus: Google Books</div>');
                        }
                    }

                    // 2. Cover
                    if (info.imageLinks) {
                        const link = info.imageLinks.thumbnail || info.imageLinks.smallThumbnail;
                        if (link) {
                            const safeLink = link.replace('&edge=curl', '');
                            localStorage.setItem(cacheKey, safeLink);
                            updateImages(safeLink);
                            return true;
                        }
                    }
                }
                return false;
            };

            let isbn = (book.isbn && book.isbn.length) ? book.isbn[0] : null;

            // 1. Try ISBN
            if (isbn) {
                try {
                    let res = await fetch(`https://www.googleapis.com/books/v1/volumes?q=isbn:${isbn}&maxResults=1`);
                    let data = await res.json();
                    if (data.items && data.items.length > 0) {
                        const gotImage = applyData(data.items);
                        if (gotImage) return;
                    }
                } catch (e) { }
            }

            // 2. Fallback: Title + Author
            let author = extractAuthor(book);
            // Fix "Sager, Riley" -> "Riley Sager"
            if (author && author.includes(',')) {
                const parts = author.split(',');
                if (parts.length === 2) {
                    author = `${parts[1].trim()} ${parts[0].trim()}`;
                }
            }

            try {
                const searchTitle = book.title || "Unknown";
                let q = `intitle:${encodeURIComponent(searchTitle)}+inauthor:${encodeURIComponent(author)}`;
                console.log(`[Detail Cover] Strategy A: ${q}`);
                let res = await fetch(`https://www.googleapis.com/books/v1/volumes?q=${q}&maxResults=1`);
                let data = await res.json();
                if (applyData(data.items)) return;

                // Strategy B: Loose
                console.log(`[Detail Cover] Retrying Strategy B (Loose)...`);
                let qLoose = `${encodeURIComponent(searchTitle)}+${encodeURIComponent(author)}`;
                let resLoose = await fetch(`https://www.googleapis.com/books/v1/volumes?q=${qLoose}&maxResults=1`);
                let dataLoose = await resLoose.json();
                applyData(dataLoose.items);

            } catch (e) { }
        }

        async function enrichWithFinnaCopies(title, author) {
            if (!title) return;
            const params = new URLSearchParams({
                lookfor: `"${title}" ${author}`,
                type: 'AllFields',
                limit: 5,
                'field[]': ['summary', 'id']
            });
            try {
                const res = await fetch(`https://api.finna.fi/v1/search?${params.toString()}`);
                const data = await res.json();
                if (data.records && data.records.length > 0) {
                    const betterRecord = data.records.find(r => r.summary && r.summary.length > 0);
                    if (betterRecord) {
                        const desc = Array.isArray(betterRecord.summary) ? betterRecord.summary.join('\n\n') : betterRecord.summary;
                        const dEl = document.getElementById('book-desc');
                        if (dEl.innerText === "") {
                            dEl.innerText = desc;
                            dEl.parentElement.style.display = 'block';
                        }
                    }
                }
            } catch (e) { }
        }

        async function findSimilarBooks(sourceBook) {
            // 0. PREPARE LANGUAGE FILTER
            const storedLangs = localStorage.getItem('selectedLanguages');
            const selectedLangs = storedLangs ? JSON.parse(storedLangs) : ['fin', 'swe', 'eng'];
            const langQuery = selectedLangs.map(l => `language:${l}`).join(' OR ');

            // 1. CLEAN & PREPARE DATA
            const formatBlocklist = ['äänikirjat', 'e-kirjat', 'cd-levyt', 'verkkoaineisto', 'pokkarit', 'isokokoiset kirjat', 'celia-aineisto'];
            const genericGenreBlocklist = ['kaunokirjallisuus', 'romaanit', 'suomenkielinen kirjallisuus', 'käännöskirjallisuus'];

            // Extract and cleanup Genres
            const rawGenres = sourceBook.genres ? sourceBook.genres.flat() : [];
            const cleanGenres = rawGenres.filter(g => {
                const lower = g.toLowerCase();
                return !formatBlocklist.some(f => lower.includes(f));
            });
            const specificGenres = cleanGenres.filter(g => !genericGenreBlocklist.includes(g.toLowerCase()));

            // Extract and cleanup Subjects (Themes)
            const rawSubjects = sourceBook.subjects ? sourceBook.subjects.flat() : [];
            const cleanSubjects = rawSubjects
                .map(s => s.replace(/\s*\(.*?\)\s*/g, '').trim()) // Remove text in parens e.g. "(fiktiivinen hahmo)"
                .filter(s => {
                    const lower = s.toLowerCase();
                    return s.length > 3 &&
                        !genericGenreBlocklist.includes(lower) &&
                        !formatBlocklist.some(f => lower.includes(f));
                });

            const uniqueSubjects = [...new Set(cleanSubjects)]; // Deduplicate after cleaning

            const audience = sourceBook.targetAudience ? sourceBook.targetAudience.flat() : [];

            // 2. BUILD QUERY
            if (specificGenres.length === 0 && uniqueSubjects.length === 0) {
                // FALLBACK: If no metadata (e.g. 2026 book), search by AUTHOR
                const author = extractAuthor(sourceBook);
                if (author) {
                    // Search for other books by this author
                    const query = `author:"${author}" AND (${langQuery})`;
                    return executeRecommendationSearch(query, sourceBook, [], [], [], true);
                }
                return;
            }

            const terms = [];
            specificGenres.slice(0, 3).forEach(g => terms.push(`genre:"${g}"`));
            uniqueSubjects.slice(0, 5).forEach(s => terms.push(`topic:"${s}"`));

            const query = `(${terms.join(' OR ')}) AND (${langQuery})`;

            executeRecommendationSearch(query, sourceBook, uniqueSubjects, specificGenres, audience, false);
        }

        async function executeRecommendationSearch(query, sourceBook, uniqueSubjects, specificGenres, audience, isAuthorFallback) {
            // Fetch candidates
            const url = `https://api.finna.fi/v1/search?lookfor=${encodeURIComponent(query)}&limit=30&field[]=id&field[]=title&field[]=images&field[]=year&field[]=subjects&field[]=genres&field[]=targetAudience&field[]=authors&field[]=isbn&field[]=formats`;

            try {
                const res = await fetch(url);
                const data = await res.json();

                // Exclude self by ID AND Title
                let candidates = data.records ? data.records.filter(r => {
                    if (r.id === sourceBook.id) return false;
                    if (r.title.toLowerCase().trim() === sourceBook.title.toLowerCase().trim()) return false;

                    // STRICT FORMAT FILTERING
                    if (r.formats) {
                        const forbidden = ['elokuva', 'video', 'dvd', 'blu-ray', 'musiikki', 'nuotti', 'peli', 'kartta', 'esine', 'partituuri', 'cd-levy', 'opinnäyte', 'thesis', 'väitöskirja', 'artikkeli', 'gradu'];
                        // Check if ANY format is forbidden (case-insensitive). Formats are objects { value, translated } or strings.
                        const hasForbidden = r.formats.some(f => {
                            const val = (typeof f === 'string' ? f : (f.translated || f.value || "")).toLowerCase();
                            return forbidden.some(forb => val.includes(forb));
                        });
                        if (hasForbidden) return false;
                    }

                    return true;
                }) : [];

                // STRICT FILTER: Fiction vs Non-Fiction separation

                const getTags = (b) => [...(b.genres || []).flat(), ...(b.subjects || []).flat()].map(t => t.toLowerCase());

                const isFiction = (b) => {
                    const tags = getTags(b);
                    const fictionKeywords = [
                        'kaunokirjallisuus', 'romaanit', 'kertomakirjallisuus',
                        'fiction', 'novel', 'novellit', 'runot', 'draama',
                        'jännityskirjallisuus', 'rikoskirjallisuus', 'fantasia', 'scifi',
                        'skönlitteratur', 'deckare', 'thriller', 'mystery', 'sagor'
                    ];
                    return tags.some(t => fictionKeywords.some(kw => t.includes(kw)));
                };

                const sourceIsFiction = isFiction(sourceBook);

                // DEDUPLICATION BY TITLE
                const uniqueMap = new Map();
                candidates.forEach(cand => {
                    let clean = cand.title;
                    // Generic cleaning
                    ["Alkuteos:", "alkuteos:", "Alkuperäisteos:", ". Suomi"].forEach(term => {
                        if (clean.includes(term)) clean = clean.split(term)[0];
                    });
                    // Aggressive cleaning: split by colon to ignore subtitles like ": romaani"
                    if (clean.includes(':')) {
                        clean = clean.split(':')[0];
                    }
                    if (clean.includes('/')) clean = clean.split('/')[0];
                    clean = clean.trim().toLowerCase().replace(/\.$/, ''); // Remove trailing dot

                    if (uniqueMap.has(clean)) {
                        const existing = uniqueMap.get(clean);
                        // Prefer existing if it has image, otherwise take new if it has image
                        if (!existing.images?.length && cand.images?.length) {
                            uniqueMap.set(clean, cand);
                        }
                    } else {
                        uniqueMap.set(clean, cand);
                    }
                });
                candidates = Array.from(uniqueMap.values());

                candidates = candidates.filter(cand => {
                    const candIsFiction = isFiction(cand);
                    if (sourceIsFiction) return candIsFiction;
                    return !candIsFiction;
                });

                // 3. RANKING ALGORITHM
                const scoredCandidates = candidates.map(cand => {
                    let score = 0;
                    let reasons = [];

                    if (isAuthorFallback) {
                        // Simple author match score
                        score = 10;
                        reasons.push(`Kirjailija: ${extractAuthor(sourceBook)}`);
                    } else {
                        // ... Standard Scoring ...
                        // A. THEME/SUBJECT MATCH
                        if (uniqueSubjects.length > 0 && cand.subjects) {
                            const candSubjects = cand.subjects.flat().map(s => s.replace(/\s*\(.*?\)\s*/g, '').trim());
                            const commonSubjects = candSubjects.filter(s => uniqueSubjects.includes(s));
                            const uniqueCommon = [...new Set(commonSubjects)];

                            if (uniqueCommon.length > 0) {
                                score += 20 * uniqueCommon.length;
                                reasons.push(`Teemat: ${uniqueCommon.slice(0, 3).join(', ')}`);
                            }
                        }

                        // B. GENRE MATCH
                        let genreMatchFound = false;
                        if (specificGenres.length > 0 && cand.genres) {
                            const candGenres = cand.genres.flat();
                            const commonGenres = candGenres.filter(g => specificGenres.includes(g));
                            const uniqueGenreCalls = [...new Set(commonGenres)];
                            if (uniqueGenreCalls.length > 0) {
                                score += 15 * uniqueGenreCalls.length;
                                reasons.push(`Yhteinen genre: ${uniqueGenreCalls.slice(0, 2).join(', ')}`);
                                genreMatchFound = true;
                            }
                        }

                        // IF NO GENRE MATCH, STILL SHOW GENRE INFO
                        if (!genreMatchFound && cand.genres) {
                            const genericGenreBlocklist = ['kaunokirjallisuus', 'romaanit', 'suomenkielinen kirjallisuus', 'käännöskirjallisuus'];
                            const formatBlocklist = ['äänikirjat', 'e-kirjat', 'cd-levyt', 'verkkoaineisto', 'pokkarit', 'isokokoiset kirjat', 'celia-aineisto'];
                            const candSpecific = cand.genres.flat().filter(g => {
                                const lower = g.toLowerCase();
                                return !genericGenreBlocklist.includes(lower) && !formatBlocklist.some(f => lower.includes(f));
                            });
                            if (candSpecific.length > 0) {
                                reasons.unshift(`Genre: ${candSpecific[0]}`);
                            }
                        }

                        // C. AUDIENCE MATCH
                        if (audience.length > 0 && cand.targetAudience) {
                            const commonAudience = cand.targetAudience.filter(a => audience.includes(a));
                            if (commonAudience.length > 0) {
                                score += 10;
                            }
                        }

                        // D. AUTHOR BONUS
                        const sourceAuth = extractAuthor(sourceBook);
                        const candAuth = extractAuthor(cand);
                        if (sourceAuth && candAuth && sourceAuth === candAuth) {
                            score += 5;
                        }
                    } // end else

                    return { book: cand, score, reasons };
                });

                const finalPicks = scoredCandidates
                    .filter(c => c.score > 0)
                    .sort((a, b) => b.score - a.score)
                    .slice(0, 6);

                if (finalPicks.length > 0) {
                    renderSimilar(finalPicks);
                }
            } catch (e) { console.warn(e); }
        }

        function renderSimilar(scoredBooks) {
            const container = document.getElementById('similar-container');
            const list = document.getElementById('similar-list');
            container.style.display = 'block';
            list.innerHTML = '';

            scoredBooks.forEach(item => {
                const b = item.book;
                // Unique reasons, join with newlines
                const reasonText = [...new Set(item.reasons)].join('\n');

                // Image Logic: Finna -> Cache -> Google Fallback -> OpenLibrary Fallback -> Placeholder
                let imgSrc = (b.images && b.images.length) ? `https://api.finna.fi${b.images[0]}` : '';

                // --- CACHE PRIORITY ---
                if (!imgSrc && b.id) {
                    imgSrc = localStorage.getItem(`cover_fix_${b.id}`);
                }
                if (!imgSrc) {
                    const author = extractAuthor(b) || "";
                    const cleanAuthor = author.includes(',') ? `${author.split(',')[1].trim()} ${author.split(',')[0].trim()}` : author;
                    const cacheKey = `cover_v5_${b.title || 'no-title'}_${cleanAuthor}`;
                    imgSrc = localStorage.getItem(cacheKey);
                }

                if (!imgSrc && b.isbn) {
                    const isbn = Array.isArray(b.isbn) ? b.isbn[0] : b.isbn;
                    imgSrc = `https://covers.openlibrary.org/b/isbn/${isbn}-M.jpg`;
                }

                const el = document.createElement('div');
                el.style.cssText = "width: 100px; cursor: pointer; flex-shrink:0;";
                el.onclick = () => window.location.href = `book.html?id=${b.id}`;
                el.title = reasonText; // Simple tooltip

                // Harmonize title for cache/search
                const cleanTitle = (b.title || "").split(/[\/\(:;]/)[0].trim();

                el.innerHTML = `
                    <div style="width:100%; aspect-ratio:2/3; background:#f0f0f0; border-radius:4px; overflow:hidden; margin-bottom:4px; position:relative;">
                        <img src="${imgSrc || ''}" class="similar-book-img" 
                             data-id="${b.id}" data-title="${cleanTitle}" 
                             data-author="${extractAuthor(b)}" 
                             style="width:100%; height:100%; object-fit:cover; display:${imgSrc ? 'block' : 'none'}" 
                             onerror="handleSimilarCoverError(this)">
                        <div class="no-cover-placeholder" style="width:100%; height:100%; display:${imgSrc ? 'none' : 'flex'}; align-items:center; justify-content:center; color:#ccc; font-size:0.8rem;">
                            ${imgSrc ? '' : 'Ei kuvaa'}
                        </div>
                    </div>
                    <div style="font-size:0.75rem; font-weight:600; line-height:1.2; overflow:hidden; text-overflow:ellipsis; display:-webkit-box; -webkit-line-clamp:2; -webkit-box-orient:vertical; margin-bottom:2px;">${b.title}</div>
                    <div style="font-size:0.7rem; color:#666; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${extractAuthor(b)}</div>
                `;
                list.appendChild(el);

                // If no image source at all, trigger background search immediately/manually
                if (!imgSrc) {
                    const img = el.querySelector('.similar-book-img');
                    handleSimilarCoverError(img);
                }
            });
        }

        // Reviews removed due to CORS/Local file restrictions
        function fetchReviews(isbn) { }
        function fetchReviewsByTitle(title, author) { }

        function renderRating(data) {
            const container = document.getElementById('reviews-container');
            container.style.display = 'block';
            const score = Math.round(data.ratings_average * 10) / 10;
            const count = data.ratings_count;
            const stars = "★".repeat(Math.round(score)) + "☆".repeat(5 - Math.round(score));

            document.getElementById('review-content').innerHTML = `
                <div style="display:flex; align-items:center; gap:8px;">
                    <span style="color:#e6b800; font-size:1.2rem; cursor:help;" title="Lähde: OpenLibrary">${stars}</span>
                    <span style="font-weight:700; font-size:1.1rem;">${score}</span>
                    <span style="color:#57606a; font-size:0.9rem;">(${count} arvostelua)</span>
                </div>
            `;
        }

        async function enrichFromSiblings(book) {
            const title = book.title;
            const author = extractAuthor(book);
            if (!title) return;
            console.log("Attempting to enrich data via Siblings for", title);

            // Search for other records (e.g. audiobook, ebook)
            // Limit 20 to cast a wide enough net
            const params = new URLSearchParams({
                lookfor: `"${title}" ${author}`,
                type: 'AllFields',
                limit: 20,
                'field[]': ['summary', 'id', 'images']
            });

            try {
                const res = await fetch(`https://api.finna.fi/v1/search?${params.toString()}`);
                const data = await res.json();

                if (data.records && data.records.length > 0) {

                    // A. Enrich SUMMARY
                    if (!book.summary || book.summary.length === 0) {
                        const betterRecord = data.records.find(r => r.summary && r.summary.length > 0);
                        if (betterRecord) {
                            console.log("Found better description from sibling:", betterRecord.id);
                            const desc = Array.isArray(betterRecord.summary) ? betterRecord.summary.join('\n\n') : betterRecord.summary;

                            const dEl = document.getElementById('book-desc');
                            // Ensure we haven't already filled it via another method
                            if (dEl.innerText.trim() === "") {
                                dEl.innerText = desc;
                                dEl.parentElement.style.display = 'block';
                            }
                        }
                    }

                    // B. Enrich IMAGE
                    // Only if we currently lack a Finna image OR are showing a placeholder/broken one
                    if (!book.images || book.images.length === 0) {
                        const betterImageRecord = data.records.find(r => r.images && r.images.length > 0);
                        if (betterImageRecord) {
                            console.log("Found better image from sibling:", betterImageRecord.id);
                            const imgSrc = `https://api.finna.fi${betterImageRecord.images[0]}`;

                            const coverDiv = document.getElementById('book-cover');
                            // Check if we are still showing placeholder text or empty
                            // We do NOT want to overwrite if Google Books already found something good? 
                            // Finna images are usually high quality, so we can prioritize them if Google hasn't finished yet or failed.

                            const currentImg = coverDiv.querySelector('img');
                            // If no image, or if image is hidden (onerror), or if it is the "Ei kuvaa" text div
                            if (!currentImg || currentImg.style.display === 'none') {
                                coverDiv.innerHTML = `<img src="${imgSrc}" alt="${book.title}" style="width:100%; height:100%; object-fit:cover;" onerror="this.style.display='none'">`;
                            }
                        }
                    }
                }
            } catch (e) {
                console.warn("Sibling enrichment failed", e);
            }
        }

        function extractAuthor(book) {
            if (!book || !book.authors) return "";
            const primary = book.authors.primary || Object.values(book.authors)[0];
            if (!primary) return "";
            return Object.keys(primary)[0] || "";
        }

        function renderBook(book) {
            document.getElementById('book-title').textContent = book.title;

            // Original Title
            let ot = book.parsedOriginalTitle || "";
            if (!ot && book.notes) {
                const otNote = book.notes.find(n => n.includes("Alkuteos:") || n.includes("Alkuperäisteos:"));
                if (otNote) ot = otNote;
            }
            if (ot) {
                document.getElementById('book-original-title').textContent = ot;
                document.getElementById('book-original-title').style.display = 'block';
            }

            const authorName = extractAuthor(book) || "Tuntematon";
            document.getElementById('book-author').textContent = authorName;

            // Year & Manual Date
            const yearEl = document.getElementById('book-year');
            let dateDisplay = book.year;

            // Apply manual date if available
            let manualDate = null;
            let manualIsbn = null;

            if (globalDates && book.title) {
                const key = book.title.toLowerCase()
                    .split(':')[0]
                    .split('/')[0]
                    .replace(/[.,]/g, '')
                    .trim();
                const entry = globalDates[key];
                if (entry) {
                    // Dates removed
                    if (entry.isbn) {
                        manualIsbn = entry.isbn;
                    }
                }
            }

            // Use manual ISBN if available, otherwise what's in the book object
            const finalIsbn = manualIsbn || (book.isbn ? (Array.isArray(book.isbn) ? book.isbn[0] : book.isbn) : null);

            // Hide/Show ISBN container
            const isbnContainer = document.getElementById('book-isbn-container');
            if (finalIsbn) {
                isbnContainer.innerHTML = `<button class="isbn-pill" title="${finalIsbn}" onclick="event.stopPropagation(); copyIsbn('${finalIsbn}', this)">ISBN</button>`;
                isbnContainer.style.display = 'flex';
            } else {
                isbnContainer.style.display = 'none';
                // Trigger fallback fetch ONLY if no manual ISBN and no API ISBN
                enrichWithGoogleIsbn(book);
            }

            // Formats Badge Generation
            let formatBadgeHtml = "";
            let isEbook = false;
            let isAudio = false;

            if (book.formats) {
                book.formats.forEach(f => {
                    const val = (typeof f === 'string' ? f : f.value) || "";
                    if (val.includes("eBook") || val.includes("EBook")) isEbook = true;
                    if (val.includes("AudioBook") || val.includes("Sound")) isAudio = true;
                });
            }

            formatBadgeHtml += isEbook ? '<span class="year-tag" style="background:#eef; color:#44a;">E-kirja</span> ' : '';
            formatBadgeHtml += isAudio ? '<span class="year-tag" style="background:#efe; color:#064;">Äänikirja</span> ' : '';
            if (!isEbook && !isAudio) {
                formatBadgeHtml += '<span class="year-tag" style="background:#f0f0f0; color:#444;">Kirja</span> ';
            }

            document.getElementById('book-formats').innerHTML = formatBadgeHtml;


            // Date specific display removed
            // if (manualDate) { ... }

            yearEl.innerHTML = dateDisplay || "";
            yearEl.title = "Julkaisuvuosi";
            yearEl.className = "year-tag"; // Ensure consistent styling

            // Redundant ISBN logic removed (handled above)


            let desc = "";
            if (book.summary && book.summary.length > 0) {
                desc = Array.isArray(book.summary) ? book.summary.join('\n\n') : book.summary;
            }

            const descEl = document.getElementById('book-desc');
            const descContainer = descEl.parentElement;

            if (desc) {
                descEl.innerText = desc;
                descContainer.style.display = 'block';
            } else {
                descEl.innerText = "";
                descContainer.style.display = 'none';
            }

            // Image with Fallback (Finna -> Cache -> OpenLibrary -> Google Placeholder -> Error)
            const coverDiv = document.getElementById('book-cover');
            coverDiv.dataset.id = book.id; // Store ID for propagation
            let imgSrc = (book.images && book.images.length > 0) ? `https://api.finna.fi${book.images[0]}` : null;

            // --- CACHE PRIORITY ---
            if (!imgSrc && book.id) {
                imgSrc = localStorage.getItem(`cover_fix_${book.id}`);
            }
            if (!imgSrc) {
                const author = extractAuthor(book) || "";
                const cleanAuthor = author.includes(',') ? `${author.split(',')[1].trim()} ${author.split(',')[0].trim()}` : author;
                const cacheKey = `cover_v5_${(book.title || 'no-title')}_${cleanAuthor}`;
                imgSrc = localStorage.getItem(cacheKey);
            }

            if (imgSrc) {
                coverDiv.innerHTML = `<img src="${imgSrc}" class="book-cover-img" alt="${book.title}" style="width:100%; height:100%; object-fit:cover;" onerror="handleDetailCoverError(this, '${book.id}')">`;
            } else if (book.isbn) {
                const isbn = Array.isArray(book.isbn) ? book.isbn[0] : book.isbn;
                const authorLow = authorName.toLowerCase();

                // Blacklist Penny ISBN from ever showing up for other authors
                if (isbn === '9789523765061' && !authorLow.includes('penny')) {
                    console.warn(`[Detail Cover] Blacklisting bad ISBN ${isbn} for cover.`);
                    coverDiv.innerHTML = `<div class="detail-loader" style="width:100%; height:100%; display:flex; align-items:center; justify-content:center; color:#888;">Haetaan kuvaa...</div>`;
                    enrichWithGoogleBooks(book, ot);
                } else {
                    imgSrc = `https://covers.openlibrary.org/b/isbn/${isbn}-L.jpg`;
                    coverDiv.innerHTML = `<img src="${imgSrc}" alt="${book.title}" style="width:100%; height:100%; object-fit:cover;" onerror="handleDetailCoverError(this, '${book.id}')">`;
                }
            } else {
                // No ISBN and no Image? Start with loading placeholder then try Google Name search
                coverDiv.innerHTML = `<div class="detail-loader" style="width:100%; height:100%; display:flex; align-items:center; justify-content:center; color:#888;">Haetaan kuvaa...</div>`;
                enrichWithGoogleBooks(book, ot); // This handles the DOM update if found
            }
        }

        window.handleDetailCoverError = function (img, id) {
            console.log(`[Detail Cover] Error loading image: ${img.src}`);

            // --- CACHE CLEANUP ---
            if (img.classList.contains('book-cover-img')) {
                console.log(`[Detail Cover] Primary source failed. Clearing cache.`);
                if (id) localStorage.removeItem(`cover_fix_${id}`);
                // Note: we don't have the clean title/author here easily without more logic, 
                // but ID cache is the primary one for detail view anyway.
            }

            // OpenLibrary failed or primary failed. Try Google.
            img.style.display = 'none';

            // Show "Ei kuvaa" text if not present
            const coverDiv = img.parentElement;
            if (coverDiv) {
                let noCover = coverDiv.querySelector('.no-cover-text');
                if (!noCover) {
                    noCover = document.createElement('div');
                    noCover.className = 'no-cover-text';
                    noCover.style.cssText = "width:100%; height:100%; display:flex; align-items:center; justify-content:center; text-align:center; color:#9fa6b2; font-size:0.85rem; padding:10px; background:#f6f8fa;";
                    noCover.textContent = "Ei kuvaa";
                    coverDiv.appendChild(noCover);
                }
                noCover.style.display = 'flex';
            }

            // Trigger name search fallback with the CORRECT ID or just inferred info
            const bookTitle = document.getElementById('book-title').textContent;
            const bookAuthor = document.getElementById('book-author').textContent;
            // Use ID if passed, otherwise fall back to name-only cache
            enrichWithGoogleBooks({ id: id || null, title: bookTitle, authors: { primary: { [bookAuthor]: [] } } }, "");
        };

        window.handleSimilarCoverError = function (img) {
            const id = img.dataset.id;
            const title = img.dataset.title;
            const author = img.dataset.author;

            if (img.classList.contains('similar-book-img')) {
                if (id) localStorage.removeItem(`cover_fix_${id}`);
            }

            img.style.display = 'none';
            const coverDiv = img.parentElement;
            if (coverDiv) {
                const placeholder = coverDiv.querySelector('.no-cover-placeholder');
                if (placeholder) {
                    placeholder.style.display = 'flex';
                    placeholder.textContent = "Ei kuvaa";
                }
            }

            if (!img.dataset.triedGoogle) {
                img.dataset.triedGoogle = "true";
                enrichWithGoogleBooks({ id: id, title: title, authors: { primary: { [author]: [] } } }, "");
            }
        };

        // Cache cleanup for faulty legacy key
        if (localStorage.getItem('cover_fix_undefined')) {
            localStorage.removeItem('cover_fix_undefined');
        }

        // Separate function to fetch ISBN specifically
        async function enrichWithGoogleIsbn(book) {
            try {
                const oldCacheKey = `isbn_${book.id}`;
                const newCacheKey = `isbn_v2_${book.id}`;

                // Cleanup bad legacy cache if current author is not Penny
                const oldVal = localStorage.getItem(oldCacheKey);
                const bookAuthor = (extractAuthor(book) || "").toLowerCase();
                if (oldVal === '9789523765061' && !bookAuthor.includes('penny')) {
                    console.log(`[Detail ISBN] Purging bad cached ISBN for ${book.title || 'Unknown'}`);
                    localStorage.removeItem(oldCacheKey);
                }

                const cached = localStorage.getItem(newCacheKey);
                if (cached) {
                    console.log(`[Detail ISBN] Cache hit (v2): ${cached}`);
                    const isbnEl = document.getElementById('book-isbn-container');
                    isbnEl.innerHTML = `<button class="isbn-pill" title="${cached}" onclick="event.stopPropagation(); copyIsbn('${cached}', this)">ISBN</button>`;
                    isbnEl.style.display = 'flex';
                    return;
                }

                // Use same search logic: Title + Author
                let author = extractAuthor(book);

                // Fix "Sager, Riley" -> "Riley Sager"
                if (author && author.includes(',')) {
                    const parts = author.split(',');
                    if (parts.length === 2) {
                        author = `${parts[1].trim()} ${parts[0].trim()}`;
                    }
                }

                console.log(`[Detail ISBN] Searching: ${book.title} | ${author}`);

                // Helper to find ISBN from items with strict verification
                const findIsbnFromItems = (items) => {
                    if (!items) return null;
                    const searchTitle = (book.title || "").toLowerCase();
                    const searchAuthorLow = (extractAuthor(book) || "").toLowerCase();

                    for (const item of items) {
                        const info = item.volumeInfo;
                        if (!info) continue;

                        const foundTitle = (info.title || "").toLowerCase();
                        const titleMatch = foundTitle.includes(searchTitle.split(':')[0].trim()) || searchTitle.includes(foundTitle.split(':')[0].trim());

                        const lastName = searchAuthorLow.split(',')[0].trim();
                        const authorMatch = info.authors && info.authors.some(a => a.toLowerCase().includes(lastName));

                        if (titleMatch && authorMatch) {
                            const ids = info.industryIdentifiers || [];
                            const isbnObj = ids.find(i => i.type === "ISBN_13" || i.type === "ISBN_10");
                            const isbn = isbnObj ? isbnObj.identifier : null;

                            if (isbn === '9789523765061' && !searchAuthorLow.includes('penny')) {
                                console.warn(`[Detail ISBN] Blacklisting Penny ISBN for ${searchAuthorLow}`);
                                continue;
                            }
                            if (isbn) return isbn;
                        } else {
                            console.log(`[Detail ISBN] Skipping mismatch: "${info.title}" by ${info.authors?.join(', ')}`);
                        }
                    }
                    return null;
                };

                // Strategy A: Specific (intitle + inauthor)
                let q = `intitle:${encodeURIComponent(book.title)}+inauthor:${encodeURIComponent(author)}`;
                let res = await fetch(`https://www.googleapis.com/books/v1/volumes?q=${q}&maxResults=5`);
                let data = await res.json();

                let found = findIsbnFromItems(data.items);

                if (found) console.log(`[Detail ISBN] Found via Strategy A: ${found}`);

                // Strategy B: Loose (just query words) if A failed
                if (!found) {
                    console.log("[Detail ISBN] Strategy A failed. Trying Strategy B...");
                    q = `${encodeURIComponent(book.title)}+${encodeURIComponent(author)}`;
                    res = await fetch(`https://www.googleapis.com/books/v1/volumes?q=${q}&maxResults=5`);
                    data = await res.json();
                    found = findIsbnFromItems(data.items);
                    if (found) console.log(`[Detail ISBN] Found via Strategy B: ${found}`);
                }

                // Strategy C: Original Title (if available)
                if (!found && book.uniformTitles && book.uniformTitles.length > 0) {
                    const originalTitle = book.uniformTitles[0];
                    console.log(`[Detail ISBN] Retrying Strategy C (Original Title): ${originalTitle}...`);
                    q = `intitle:${encodeURIComponent(originalTitle)}+inauthor:${encodeURIComponent(author)}`;
                    res = await fetch(`https://www.googleapis.com/books/v1/volumes?q=${q}&maxResults=5`);
                    data = await res.json();

                    found = findIsbnFromItems(data.items);
                    if (found) console.log(`[Detail ISBN] Found via Strategy C: ${found}`);
                }

                if (found) {
                    localStorage.setItem(newCacheKey, found);
                    const isbnEl = document.getElementById('book-isbn-container');
                    isbnEl.innerHTML = `<button class="isbn-pill" title="${found}" onclick="event.stopPropagation(); copyIsbn('${found}', this)">ISBN</button>`;
                    isbnEl.style.display = 'flex';
                } else {
                    console.warn("[Detail ISBN] No ISBN found after all strategies.");
                }

            } catch (e) {
                console.warn("[Detail ISBN] Fetch error:", e);
            }
        }

        window.copyIsbn = function (text, btn) {
            if (!text) return;
            const originalText = btn.textContent;

            const feedback = (success) => {
                btn.textContent = success ? "Kopioitu!" : "Virhe";
                // Keep style neutral or success
                btn.style.borderColor = success ? "#2da44e" : "#cf222e";
                btn.style.color = success ? "#2da44e" : "#cf222e";
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.borderColor = "";
                    btn.style.color = "";
                }, 2000);
            };

            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(text).then(() => feedback(true)).catch(() => feedback(false));
            } else {
                try {
                    const textArea = document.createElement("textarea");
                    textArea.value = text;
                    document.body.appendChild(textArea);
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                    feedback(true);
                } catch (err) {
                    prompt("Kopioi ISBN:", text);
                    feedback(true);
                }
            }
        };

    </script>
</body>

</html>